---
title: "Midterm Report for JSphere: Classification of The Use of JavaScript on The Web"
subtitle: "Project B for CSci 651 by John Heidemann"
author:
    - name: Steven Hé (Sīchàng)
    - name: "Mentor: Harsha V. Madhyastha"
format:
    html:
        html-math-method: katex
    pdf:
        pdf-engine: latexmk
        papersize: a4
        margin-left: 1in
        margin-right: 1in
        margin-top: 1in
        margin-bottom: 1in
        indent: 2m
        number-sections: true
bibliography: main.bib
csl: acm-sig-proceedings-long-author-list.csl
---

# Weekly Meeting Notes

<!-- Provide a URL to your weekly meeting notes. These need to be accessible to the professor. -->
Link to Weekly Meeting Notes: TODO: add this in private repo.

# Introduction

<!-- Provide an overview of the need you are addressing, what you are doing and plan to do, the novelty and new results of your work, and why this work is interesting to you personally. -->

JavaScript (JS) plays a central role in modern web content delivery,
accounting for approximately 25% of transferred bytes and 50% of
compute delay for the median webpage [@httparchive2024web;
@httparchive2024javascript; @goel2024sprinter].
Despite its widespread use, the reasons behind the extensive utilization of
JS remain understudied.
While industry observations suggest much of
this JS is unnecessary [@ceglowski2015website],
research efforts have primarily focused on security vulnerabilities,
privacy invasions, and performance issues [@snyder2016browser;
@iqbal2021fingerprinting; @mardani2021horcrux].

This project, JSphere, aims to classify the functionalities of JS code on
top websites on the public Web. By understanding the common uses of JS,
we can potentially guide developers in optimizing their websites,
improve general online browsing experiences, and inform future utilization of
the Internet for serving Web content.

We propose to classify each JS file in the top 1000 websites into one or
more of the following categories, which we call spheres:

1. Frontend processing
1. DOM element generation
1. UX enhancement
1. Extensional features
1. Silent code

Our approach involves analyzing JS browser API calls when interacting with
these websites,
using a modified Chromium browser called VisibleV8 [@jueckstock2019visiblev8].
This work is personally interesting as
it bridges the gap between theoretical understanding of web technologies and
their practical implementation, potentially leading to more efficient and
user-friendly web experiences.

# Related Work

<!-- Summarize prior work related to yours and describe how your work compares. Include complete citations to the prior work. -->

<!-- TODO: This cannot repeat the introduction. We need more content instead. -->

Our work differs from these previous studies by
providing a comprehensive classification of
have functionalities across major websites.
This classification aims to bridge the gap between performance analysis and
feature usage studies, offering insights into why so
much JavaScript is used and how effective it is in
achieving its intended purposes.

# JSphere

## Goal

<!-- Describe the goal of your project. -->

The primary goal of JSphere is to classify the functionalities of
JavaScript code on top websites on the public Web. Specifically, we aim to
categorize each JS file in the top 1000 websites into one or more of
the following spheres:
<!-- TODO: This aim seems too specific. -->

- Frontend processing (e.g., user interaction, form validation).
- DOM element generation (including styling application).
- UX enhancement (e.g., animations and effects).
- Extensional features (e.g., authentication and analytics).
- Silent code (code that does not call any JS APIs, likely never executed).

By achieving this classification, we hope to
provide insights into the common uses of JavaScript, which
can inform developers, improve user experiences, and
guide future web development practices.

## Methods

<!-- Explain the methodology or approach you are using in your project. -->

We leverage web crawling to collect API call logs, then analyze these logs to
classify JS files on the top 1000 subdomains.

### Web Crawling

We visit and interact with webpages in a fashion used in [@snyder2016browser].
For each subdomain, we visit the root page, 3 second-level linked webpages, and
9 third-level webpages, repeating this process five times.
After each webpage's `load` event fires, we conduct "chaos testing",
randomly interacting with the webpage's elements for 30 seconds in total.
During interactions, we block all page navigations by
fulfilling such requests with an HTML page containing a single JS block to
go back in history, and record this navigation attempt for the second- and
third-level linked webpages.
With the browser's back-forward cache enabled,
we find this method reliably resumes the interaction, with
infrequent glitches that we detect and solve by visiting the page again.
We use Playwright to automate this browsing process and inject Gremlins.js for
the chaos testing.
<!-- TODO: Shall I talk about the client location? -->

While loading and interacting with webpages,
VisibleV8 records the API calls they make and provides logs for our analysis.
VisibleV8 is a modified Chromium browser [@jueckstock2019visiblev8]; for
each Chromium thread, it writes a log file that
contains each script context and browser API call made in that
context [@jueckstock2019visiblev8].
We open a new page every time we visit a page to ensure all API calls in
each log file before our injected interaction script are made during page
loading.

We also collect the HTTP Archive (HAR) files for potential further analysis.

### Log Processing

We parse the VisibleV8 logs to aggregate the API calls of each script context.
A script context is either a standalone JavaScript file being executed,
a script tag in an HTML file, or a script created using `eval()`.
For each context, we group API calls made based on their API types, `this`
values, and attributes accessed, e.g., a Get API on `Window`'s `scrollY`
attribute, and count the presence of each API call group.
Our custom Rust library powers this processing.

We divide API calls into two portions: calls made during page loading and
calls made after interaction begin.
This division helps us filter out API calls not made for interaction handling.
We make this distinction based on when the browser enters a context of
our injected interaction script in the log file.

Additional to the API call logs, we also collect the script sizes in bytes from
their source code provided in the logs.
The script sizes may be a more indicative metric than script counts because
they better reflect the transferred bytes and the execution time of
the scripts, which directly affect user experiences.

### Heuristics for Classification

We count specific "anchor" APIs that strongly indicate specific spheres, and
develop heuristics based on them to determine if
a script context falls under a sphere.
<!-- TODO: Describe the current heuristics. -->

The current heuristics are subject to change.

## Data Collection

<!-- Detail the data collection process. -->
Data collection was performed through
an automated crawling process using Playwright.
The crawler visited a predefined list of websites, performing interactions and
capturing API call traces. The data collection process involved several steps.

We selected the top 100 websites based on traffic and relevance to our study.
The crawler simulated user interactions on each site,
capturing API call traces during both the page load and interaction phases.
The collected data, including logs, HAR files, and JSON files, were stored in
a structured format for easy access and analysis.

## Results

<!--
For Project B, you should have at least one preliminary result.
If you have other results that are incomplete but expected for Project C,
you can also describe what you plan to do.
-->

### Preliminary Results

<!-- Present any preliminary results you have obtained. If you have other results that are incomplete but expected for Project C, describe what you plan to do. -->
Our preliminary results indicate a tail-heavy distribution of API calls, with
a small percentage of APIs accounting for the majority of calls.
Key findings include that it takes 1.75% (318) of APIs to cover 80% of
all API calls, and 3.74% (678) of APIs to cover 90%.
Many API calls occur before user interactions begin, with DOM and
event APIs dominating the absolute counts.
We identified several "anchor" APIs that strongly indicate specific behaviors,
such as `addEventListener` for Frontend Processing and `createElement` for
DOM Element Generation.

### Expected Results

We expect to further refine our classification heuristics and
improve the accuracy of our script behavior analysis.
Future work will involve developing more sophisticated heuristics to
classify APIs into their respective categories with higher precision.
We also plan to implement log compression and
better data management techniques to handle large volumes of data efficiently.
Additionally, we aim to expand the analysis to a larger set of websites and
explore targeted event listener tests to complement our chaos testing approach.
By continuing to refine our methodology and expand our dataset, we aim to
provide a comprehensive understanding of JavaScript behavior across the web.

# Next Steps for Research Project C

<!-- Describe the next steps for Research Project C. Include a checklist of specific deliverables for Project C:
- Continuing to meet once a week with your mentor
- Continued weekly notes about your progress
- Expected end results (code or experiments)
- Project C report -->

# References {.unnumbered}
<!-- Include a bibliography with at least the citations from the related work section. -->
